<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libsysve: VE AIO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsysve
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__veaio.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">VE AIO</div>  </div>
</div><!--header-->
<div class="contents">

<p>VE AIO is a asynchronous I/O feature for VE programs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac04a80af1c8a785724bfd4a501096ab7"><td class="memItemLeft" align="right" valign="top">struct ve_aio_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__veaio.html#gac04a80af1c8a785724bfd4a501096ab7">ve_aio_init</a> (void)</td></tr>
<tr class="memdesc:gac04a80af1c8a785724bfd4a501096ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a new ve_aio_ctx managing a read/write request.  <a href="#gac04a80af1c8a785724bfd4a501096ab7">More...</a><br/></td></tr>
<tr class="separator:gac04a80af1c8a785724bfd4a501096ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf208367c4381fbd161a420c3cb1c48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__veaio.html#ga6bf208367c4381fbd161a420c3cb1c48">ve_aio_fini</a> (struct ve_aio_ctx *ctx)</td></tr>
<tr class="memdesc:ga6bf208367c4381fbd161a420c3cb1c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases context managing a read/write request.  <a href="#ga6bf208367c4381fbd161a420c3cb1c48">More...</a><br/></td></tr>
<tr class="separator:ga6bf208367c4381fbd161a420c3cb1c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9beab2b6a401b025cbb931205e93acca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__veaio.html#ga9beab2b6a401b025cbb931205e93acca">ve_aio_read</a> (struct ve_aio_ctx *ctx, int fd, ssize_t count, void *buf, off_t offset)</td></tr>
<tr class="memdesc:ga9beab2b6a401b025cbb931205e93acca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts asynchronous read.  <a href="#ga9beab2b6a401b025cbb931205e93acca">More...</a><br/></td></tr>
<tr class="separator:ga9beab2b6a401b025cbb931205e93acca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea114dccdd5d6030c648cc66dde38a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__veaio.html#ga7ea114dccdd5d6030c648cc66dde38a1">ve_aio_write</a> (struct ve_aio_ctx *ctx, int fd, ssize_t count, void *buf, off_t offset)</td></tr>
<tr class="memdesc:ga7ea114dccdd5d6030c648cc66dde38a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts asynchronous write.  <a href="#ga7ea114dccdd5d6030c648cc66dde38a1">More...</a><br/></td></tr>
<tr class="separator:ga7ea114dccdd5d6030c648cc66dde38a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac134802db58fcdf2d581681c4af8e574"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__veaio.html#gac134802db58fcdf2d581681c4af8e574">ve_aio_query</a> (struct ve_aio_ctx *ctx, ssize_t *retval, int *errnoval)</td></tr>
<tr class="memdesc:gac134802db58fcdf2d581681c4af8e574"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets state of read/write operation for the context.  <a href="#gac134802db58fcdf2d581681c4af8e574">More...</a><br/></td></tr>
<tr class="separator:gac134802db58fcdf2d581681c4af8e574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga667a5ae7564e7db279f10719ded0caf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__veaio.html#ga667a5ae7564e7db279f10719ded0caf7">ve_aio_wait</a> (struct ve_aio_ctx *ctx, ssize_t *retval, int *errnoval)</td></tr>
<tr class="memdesc:ga667a5ae7564e7db279f10719ded0caf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function waits read/write request for the context.  <a href="#ga667a5ae7564e7db279f10719ded0caf7">More...</a><br/></td></tr>
<tr class="separator:ga667a5ae7564e7db279f10719ded0caf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>VE AIO is a asynchronous I/O feature for VE programs. </p>
<p>VE programs can do their own tasks while data transfer between VE and VH and actual I/O are done asynchronously.</p>
<p>Please include "veaio.h". Please specify "-lveio -pthread" option to the compiler driver to link libveio.</p>
<dl class="section note"><dt>Note</dt><dd>VE AIO expects an ordinary file opened without O_DIRECT flag. Socket, pipe or fifo can't be used. </dd>
<dd>
Calling fork() or vfork() when read/write operation status is in progress, invoking AIO API results in undefined behavior. Check read/write operation status by using <a class="el" href="group__veaio.html#gac134802db58fcdf2d581681c4af8e574" title="This function gets state of read/write operation for the context. ">ve_aio_query()</a> or synchronize read/write operation by using <a class="el" href="group__veaio.html#ga667a5ae7564e7db279f10719ded0caf7" title="This function waits read/write request for the context. ">ve_aio_wait()</a>. </dd>
<dd>
Pseudo process(ve_exec) creates a thread and opens two files to submit a read/write request. So, the maximum number of read/write requests which a VE program can submit at same time is depend on the following limits.<ol type="1">
<li>The number of processes which can be created on VH (per user)</li>
<li>The number of files which can be opened per process </li>
</ol>
</dd>
<dd>
If VE thread which has submitted read/write request terminates before completion of read/write operation, then VE process gets abnormal termination. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac04a80af1c8a785724bfd4a501096ab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ve_aio_ctx* ve_aio_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a new ve_aio_ctx managing a read/write request. </p>
<dl class="section note"><dt>Note</dt><dd>User must initialize a ve_aio_ctx for AIO operation </dd>
<dd>
User must invoke this function as many as multiplicity of read/write requests </dd>
<dd>
For example, initialize two contexts to submit two read/write requests at a time </dd>
<dd>
Context can be reused after completion of previous request </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ve_aio_ctx</td><td>on success </td></tr>
    <tr><td class="paramname">NULL</td><td>on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6bf208367c4381fbd161a420c3cb1c48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ve_aio_fini </td>
          <td>(</td>
          <td class="paramtype">struct ve_aio_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function releases context managing a read/write request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to be released</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-1</td><td>on failure and following errno is set<ul>
<li>EINVAL Context in arguments is invalid</li>
<li>EBUSY Request for this context is in progress </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9beab2b6a401b025cbb931205e93acca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ve_aio_read </td>
          <td>(</td>
          <td class="paramtype">struct ve_aio_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts asynchronous read. </p>
<dl class="section note"><dt>Note</dt><dd>This function internally invokes pread() system call at VH side </dd>
<dd>
Context can be reused after completion of previous request </dd>
<dd>
Number of bytes read at once is restricted to 2GB as well as pread()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context managing this request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor which refer to a file this function reads to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of bytes read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer this function reads from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>File offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-1</td><td>on failure and following errno is set<ul>
<li>EINVAL Context in arguments is invalid</li>
<li>EBUSY Not complete the previous read request for this context</li>
<li>EAGAIN No resource to accept this request</li>
<li>ENOMEM No memory to accept this request on host </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7ea114dccdd5d6030c648cc66dde38a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ve_aio_write </td>
          <td>(</td>
          <td class="paramtype">struct ve_aio_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts asynchronous write. </p>
<dl class="section note"><dt>Note</dt><dd>This function internally invokes pwrite() system call at VH side </dd>
<dd>
Context can be reused after completion of previous request </dd>
<dd>
Number of bytes written at once is restricted to 2GB as well as pwrite()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context managing this request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor which refer to a file function writes to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of bytes written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Buffer this function writes from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>File offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-1</td><td>on failure and following errno is set<ul>
<li>EINVAL Context in arguments is invalid</li>
<li>EBUSY Not complete the previous read request for this context</li>
<li>EAGAIN No resource to accept this request</li>
<li>ENOMEM No memory to accept this request on host </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac134802db58fcdf2d581681c4af8e574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ve_aio_query </td>
          <td>(</td>
          <td class="paramtype">struct ve_aio_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t *&#160;</td>
          <td class="paramname"><em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>errnoval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets state of read/write operation for the context. </p>
<dl class="section note"><dt>Note</dt><dd>If argument *retval or *errnoval below is NULL, status of read/write can be got but return value or error number can not be got</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context which this function gets some information from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retval</td><td>Pointer to get return value of pread()/pwrite() </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errnoval</td><td>Pointer to get error number of pread()/pwrite()</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on completion of read/write and set retval and errnoval </td></tr>
    <tr><td class="paramname">1</td><td>on incompletion read/write </td></tr>
    <tr><td class="paramname">-1</td><td>on failure of query and following errno is set<ul>
<li>EINVAL Context in arguments is invalid </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga667a5ae7564e7db279f10719ded0caf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ve_aio_wait </td>
          <td>(</td>
          <td class="paramtype">struct ve_aio_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t *&#160;</td>
          <td class="paramname"><em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>errnoval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function waits read/write request for the context. </p>
<dl class="section note"><dt>Note</dt><dd>When read or write is failure (actually, pread or pwrite is used internally), its error number is set </dd>
<dd>
This function blocks VE process so VEOS finds other process to schedule </dd>
<dd>
After context was reused, this function gets result of latest request for ve_aio_ctx </dd>
<dd>
When this function fails, retval and errnoval are not set</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context managing read/write request </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retval</td><td>Pointer to get return value of pread()/pwrite() </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errnoval</td><td>Pointer to get error number of pread()/pwrite()</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on completion of read/write and set retval and errnoval </td></tr>
    <tr><td class="paramname">-1</td><td>on failure of wait and following errno is set<ul>
<li>EINVAL Context in arguments is invalid</li>
<li>EBUSY Context in arguments has already managed new read/write request and failure to get result of previous request </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
